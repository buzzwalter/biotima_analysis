# -*- coding: utf-8 -*-
"""calibration_analysis_chain.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NnuclLpexIALM_KdZDf2UHajvLSgKFuq

## Analysis Chain Draft

### Dependencies
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, filtfilt
from scipy.optimize import leastsq

# Needed for google collab run but dont include if you're running locally
from google.colab import drive
drive.mount('/content/gdrive', force_remount=True)

root_dir = "/content/gdrive/My Drive/"
base_dir = root_dir + 'uni_wien/BIOTIMA/2024_03_21-library-calibration/'

"""emgfit is a python package for analyzing ToF mass spec data which primarily focuses on the [hyper exponentially modified gaussian distribution](https://sci-hub.st/https://doi.org/10.1016/j.ijms.2017.07.014) which was specially designed for ToF related ion beams which experience skewness in both positive and negative directions due to diffusion of the ion beam.  This analysis is critical to fitting isometric states of a species as is outlined in https://journals.aps.org/prc/pdf/10.1103/PhysRevC.99.064313

The tutorial can be found on this page
https://robbenroll.github.io/emgfit/v0.5.0/emgfit_tutorial.html#Import-data

most of the information required to understand this library and how to use it can be found in these three sources assuming comforability with python.
"""

# if you already have emgfit installed this cell doesn't need to be executed -- must always be executed on collab
 !pip install --upgrade emgfit

import emgfit as emg
print(emg.__version__)

"""### Pre-Processing

volt per count from binning analysis ~ $3 \times 10^{-5} $ V, but discussing with pg suggests it would closer to milivolts.  

In principle when our acquistion system is setup properly, we should retreive count data in real time.  This is critical to the analysis since all of what underlies our analysis is poissonian statistics

Solution for now:  for a similar effect relative to the way the library works we just work in different units
"""

df = pd.read_csv(base_dir + 'library_calibration_ChD165_lens2cm_desoprt100uJ_MCP2.3_avg256.csv',delimiter=',',names=['time','volts'])
df['time'] = df['time']*1e6 ## covert to microseconds
df['volts'] = df['volts']*(-1e3) # convert to inverted milivolts

df.values[:,0] # nano second division of which we have 5000 ---> 88.75,138.75

"""Also: the charging up of the ToF introduces a slant to the time series data, so the floor of this signal needs to be removed first"""

# Step 1: Apply a low-pass Butterworth filter
def butter_lowpass_filter(data, cutoff, fs, order=5):
    nyq = 0.5 * fs
    normal_cutoff = cutoff / nyq
    b, a = butter(order, normal_cutoff, btype='low', analog=False)
    y = filtfilt(b, a, data)
    return y

# Define the cutoff frequency as appropriate for your data
cutoff_frequency = 1e3  # Adjust this based on your specific data
sampling_rate = 10000  # Adjust based on your time series data sampling rate

filtered_volts = butter_lowpass_filter(df['volts'], cutoff_frequency, sampling_rate)

# Step 2 Fit a line using least squares
time = df['time'].to_numpy()
slope, intercept = np.polyfit(time, filtered_volts, 1)

# Step 3: Subtract the fitted line from the original data
fitted_line = slope * time + intercept
corrected_volts = df['volts'] - fitted_line
corrected_volts[corrected_volts <0] = 0 # remove negative counts
# Optional: Save or plot the corrected data
#df['corrected_volts'] = corrected_volts
# df.to_csv('corrected_data.csv')  # Save to a new file

fig, ax = plt.subplots(figsize=(8,6))
plt.plot(corrected_volts,alpha=0.5,c='b')
plt.plot(df['volts'],alpha=0.5, c='r')
plt.plot(fitted_line,c='teal')
plt.legend(['correceted','original','fitted floor: $y = {:.4f}x + {:.4f}$'.format(slope,intercept)])

columns = ['Mass','Counts']
data = np.zeros((len(corrected_volts),2))
data[:,0] = df['time'].to_numpy()
data[:,1] = corrected_volts
emg_df = pd.DataFrame(dict(zip(columns, data)))

#1.49639e12*(0.00015-0.0000974)**2 # from previous 2.4 calibration

# set the data frame to counts
#count_volt = -1e-3 #bin_min
#df['Counts'] = df['Counts']/count_volt
#df['Mass'] = 1496387160000*(df['Mass']-0.0000873911923)**2
#df = df.rename(columns={'time (s)': "Mass",'voltage (V)': 'Counts'}, inplace=True)

np.savetxt('emg_spec_2.3.txt',data)

"""### Calibration
emg is intended for already calibrated data, i.e. two column data of mass/charge and counts, so when visualizing the non-calibrated data, the labels on the axes must be ignored.  However, the library is still useful for determining the peaks.
"""

m_start = 172 # low-mass cut off
m_stop = 195 # high-mass cut off
resolving_power = 1e4 # resolving power to use for shape parameter initialization
spec = emg.spectrum('emg_spec_2.3.txt',m_start=m_start,m_stop=m_stop,resolving_power=resolving_power)

# naphalene peak
m_start = 176 # low-mass cut off
m_stop = 177 # high-mass cut off
resolving_power = 1e4 # resolving power to use for shape parameter initialization
spec_naph = emg.spectrum('emg_spec_2.3.txt',m_start=m_start,m_stop=m_stop,resolving_power=resolving_power)

spec_naph.detect_peaks(thres=2e-2,window='bartlett',window_len=9,width=1e-4)#2.25e-3,window_len=99,thres=10,plot_smoothed_spec=True,plot_2nd_deriv=True,plot_detection_result=True) 190	250.34	514.6	614.7	720.7	840.8	1008

# pentacene peak
m_start = 178 # low-mass cut off
m_stop = 179 # high-mass cut off
resolving_power = 1e4 # resolving power to use for shape parameter initialization
spec_pent = emg.spectrum('emg_spec_2.3.txt',m_start=m_start,m_stop=m_stop,resolving_power=resolving_power)

"""Pentacene has iosotope distrubtion

mass | P
---|---
278.10955 | 100
279.11291 | 23.8
279.11583 | 0.2
280.11626 | 2.7
280.11919 | 0.1
281.11962 | 0.2

"""

spec_pent.detect_peaks(thres=2e-2,window='bartlett',window_len=9,width=1e-4)#2.25e-3,window_len=99,thres=10,plot_smoothed_spec=True,plot_2nd_deriv=True,plot_detection_result=True) 190	250.34	514.6	614.7	720.7	840.8	1008

"""1 2 and 4 seem like they could be the largest probability masses at 278 279 and 280, but it seems to biased to say one way or the other.  Only the main peak can really be assigned -- maybe the 279 as well.   """

# Phthalocyanine peak
m_start = 182 # low-mass cut off
m_stop = 184 # high-mass cut off
resolving_power = 1e4 # resolving power to use for shape parameter initialization
spec_pthal = emg.spectrum('emg_spec_2.3.txt',m_start=m_start,m_stop=m_stop,resolving_power=resolving_power)

"""Phthalocyanine has iosotope distrubtion

mass | P
---|---
514.16544 | 100
515.16248 | 2.9
515.1688 | 34.6
515.17172 | 0.3
516.16584 | 1
516.17215 | 5.8
516.17508 | 0.1
517.16919 | 0.2
517.17551 | 0.6
"""

spec_pthal.detect_peaks(thres=8e-3,window='bartlett',window_len=9,width=1e-4)#2.25e-3,window_len=99,thres=10,plot_smoothed_spec=True,plot_2nd_deriv=True,plot_detection_result=True) 190	250.34	514.6	614.7	720.7	840.8	1008

"""The three most probable appear to be the sequence 0, 1, and 2"""

# tpp peak
m_start = 184 # low-mass cut off
m_stop = 185 # high-mass cut off
resolving_power = 1e4 # resolving power to use for shape parameter initialization
spec_tpp = emg.spectrum('emg_spec_2.3.txt',m_start=m_start,m_stop=m_stop,resolving_power=resolving_power)

"""TPP has iosotope distrubtion

mass | P
---|---
614.24705 | 100
615.24408 | 1
615.25041 | 48
616.24744 | 1
616.25376 | 11
617.25712 | 2
"""

spec_tpp.detect_peaks(thres=8e-3,window='bartlett',window_len=9,width=1e-4)#2.25e-3,window_len=99,thres=10,plot_smoothed_spec=True,plot_2nd_deriv=True,plot_detection_result=True) 190	250.34	514.6	614.7	720.7	840.8	1008

"""This peak was what we used to calibrate the ToF control parameters, so the 1,2,3 and 4 peaks appear to be the four most probable peaks in order. We calibrated to previous signals that have been observed, which included the peak prior.  Part of the point of using the new ToF is for observing the validity of this lower mass peak.   """

# c60 peak
m_start = 186 # low-mass cut off
m_stop = 187 # high-mass cut off
resolving_power = 1e4 # resolving power to use for shape parameter initialization
spec_c60 = emg.spectrum('emg_spec_2.3.txt',m_start=m_start,m_stop=m_stop,resolving_power=resolving_power)

"""C60 has iosotope distrubtion

mass | P
---|---
720 | 100
721.00336 | 64.9
722.00671 | 20.7
723.01007 | 4.3
724.01342 | 0.7
725.01678 | 0.1
"""

spec_c60.detect_peaks(thres=8e-3,window='bartlett',window_len=9,width=1e-4)#2.25e-3,window_len=99,thres=10,plot_smoothed_spec=True,plot_2nd_deriv=True,plot_detection_result=True) 190	250.34	514.6	614.7	720.7	840.8	1008

"""The first four are comfortably present as 0,1,2, and 3"""

# c70 peak
m_start = 187 # low-mass cut off
m_stop = 189 # high-mass cut off
resolving_power = 1e4 # resolving power to use for shape parameter initialization
spec_c70 = emg.spectrum('emg_spec_2.3.txt',m_start=m_start,m_stop=m_stop,resolving_power=resolving_power)

"""C70 has iosotope distrubtion

mass | P
---|---
840 | 100
841.00336 | 75.7
842.00671 | 28.3
843.01007 | 6.9
844.01342 | 1.3
845.01678 | 0.2
"""

spec_c70.detect_peaks(thres=9e-3,window='bartlett',window_len=9,width=1e-4)#2.25e-3,window_len=99,thres=10,plot_smoothed_spec=True,plot_2nd_deriv=True,plot_detection_result=True) 190	250.34	514.6	614.7	720.7	840.8	1008

"""The most probable five appear to be 6, 7, 8, 9, and 10"""

# c84 peak
m_start = 189 # low-mass cut off
m_stop = 191 # high-mass cut off
resolving_power = 1e4 # resolving power to use for shape parameter initialization
spec_c84 = emg.spectrum('emg_spec_2.3.txt',m_start=m_start,m_stop=m_stop,resolving_power=resolving_power)

"""C84 has iosotope distrubtion

mass | P
---|---
1008 | 100
1009.00336 | 90.9
1010.00671 | 40.8
1011.01007 | 12.1
1012.01342 | 2.6
1013.01678 |0.5
1014.02013 | 0.1

"""

spec_c84.detect_peaks(thres=6e-3,window='bartlett',window_len=9,width=1e-4)#2.25e-3,window_len=99,thres=10,plot_smoothed_spec=True,plot_2nd_deriv=True,plot_detection_result=True) 190	250.34	514.6	614.7	720.7	840.8	1008



"""The peaks 10-13 appear to be the four most probable.  The other three peaks which look like the convolved signal, just represent the well known reducing due to diamers being released (C78,C80,C82). For carbon molecules this large, the two largest peaks are always about equal, so for the diamer related peaks, these we can assign two peaks each.

Ultimately these closeups on the peaks wont be the primary spec instance we will use for fitting. They are just for visualization and exploration.

That being said, these close ups can give us an idea how of

1. which limiting threshold value we need for the overall 2nd derivative analysis
2. which masses correspond to which peaks, isotopes included -- since there'll be more peaks than we need given the fact that the max threshold will generate a lot of peaks due to the limiting threshold.
"""



spec.detect_peaks(thres=6e-3,window='bartlett',window_len=9,width=1e-4)#2.25e-3,window_len=99,thres=10,plot_smoothed_spec=True,plot_2nd_deriv=True,plot_detection_result=True) 190	250.34	514.6	614.7	720.7	840.8	1008

"""If we look at this table relative to our previous investigation of the individual peaks in order of mass, we see the relevant peaks are 43(Naph), 82-83(Pent), 120-122(Phth), 128-131(TPP), 139-142(C60), 153-157(C70), 166-167(C78), 168-169(C80), 171-172(C82), 176-179(C84)

We can handle the whole recalibration within the emg framework. The way we reference the the istopes in emg is by including the string

```
'm$I'
```

after the chemical formula sequence. In the above string, I is the integer of the ith isometric state.  Information on all the notation can be found [here](https://robbenroll.github.io/emgfit/v0.5.0/concepts.html#notation-of-chemical-substances).  Looking at the assingments done below will give a sense of how it works.  With isotope resolution the main peak is always the 0th isometric state and then the following istopes are reference with 'm1'...'mn'

For the calibration, it is assumed to be sufficient to use the main isometric states
"""

calib_mass_list = []
calib_peak_indices = [43,82,120,128,139,153,166,168,171,176]
calib_peak_times = []
calib_list = ['10C12:6H1:4O16m0:-1e','22C12:14H1m0:-1e','32C12:18H1:8N14m0:-1e','44C12:30H1:4N14m0:-1e','60C12m0:-1e','70C12m0:-1e','78C12m0:-1e','80C12m0:-1e','82C12m0:-1e','84C12m0:-1e']
for calib_index,calib_species in zip(calib_peak_indices,calib_list):
  calib_mass_list.append(emg.ame_funcs.get_AME_values(calib_species,1e-10)[0]) # retrieve mass values from AME 1e-10 is just because you can't put in 0 Kev for the isometric excitation. 1e-10 is effective 0
  calib_peak_times.append(spec.peaks[calib_index].x_pos*1e-6) # convert back to seconds

calib_peak_times

# define fit function
def mass_func(a,b,x):
    return a*(x-b)**2

def mass_func_residual(p,x,t):
    a,b = p
    sim = mass_func(a,b,x)
    return t-sim

#calibrations_container = []
# mcps = ['2.2','2.3', '2.4', '2.5', '2.6', '2.7']
fig, axs = plt.subplots(figsize=(8, 6))
# mcps_time_peaks = df.values[:,1]
# mcps_mass_peaks = df.values[:,0]
t = calib_mass_list
time_data = np.array(calib_peak_times)


p_0 = [1e12,1e-5]
pfit , pcov = leastsq(mass_func_residual,p_0,args=(np.array(time_data),t),full_output=1)[:2]
#calibrations_container.append(np.vstack((pfit,pcov.diagonal())))

axs.plot(np.array(time_data)*1e6,t,'.')
axs.plot(np.array(time_data)*1e6,mass_func(pfit[0],pfit[1],time_data))
title_string = "MCP 2.3"
#title_string = 'MCP ' + mcps[i] + '   a='+"{:.2e}".format(pfit[0]) + ' (amu/$s^2$) '+ '   $t_0$='+ "{:.2e}".format(pfit[1]) + ' (s)'
axs.set(xlabel='time(us)', ylabel = 'mass($\sqrt{amu}$)', title=title_string)
print("a={0:.6E} and t_0 = {1:.6E}".format(*pfit))

pd.DataFrame(np.vstack((t,mass_func(pfit[0],pfit[1],time_data), np.abs(mass_func_residual(pfit,time_data,t)))).T,columns=["target","model","residual"])

data[:,0] = mass_func(pfit[0],pfit[1],df['time'].to_numpy()*1e-6)
start_index = np.argmin(data[:,0])
plt.plot(data[start_index:start_index+30000,0],data[start_index:start_index+30000,1])
plt.xlabel('amu/q')
relevant_subset = np.vstack((data[start_index:start_index+30000,0],data[start_index:start_index+30000,1])).T
np.savetxt('emg_spec_2.3_calibrated.txt',relevant_subset)

"""### Isometric Observations

It is well known that the shape of peaks throughout a ToF spectrum is preserved. The first step here will be to look for a well separated peak to do shape calibration with.    Then the masses can be looked at across the whole original list of 180 peaks found by the peak finder.
"""

# naphalene peak
m_start = 187 # low-mass cut off
m_stop = 193 # high-mass cut off
resolving_power = 1e4 # resolving power to use for shape parameter initialization
spec_naph = emg.spectrum('emg_spec_2.3_calibrated.txt',m_start=m_start,m_stop=m_stop,resolving_power=resolving_power)

spec_naph.detect_peaks(thres=1.8e-2,window='bartlett',window_len=9,width=1e-4)#2.25e-3,window_len=99,thres=10,plot_smoothed_spec=True,plot_2nd_deriv=True,plot_detection_result=True) 190	250.34	514.6	614.7	720.7	840.8	1008

"""5,8-Dihoydroxy-1,4-naphthochinon has iosotope distrubtion

mass | P
---|---
190.02663 | 100
191.02999 |10.8
191.03084 |0.2
191.03291 |0.1
192.03087 |0.8
192.03334 |0.5
193.03423 |0.1

In principle 1 and 2 should correspond to the most probable, but understanding the rest of peaks is difficult.  One could argue in favor of fitting the highest peak to the the most abundent mass or the first peak to the most abundent mass, but in prinicple they should be one in the same for most signal.  Part of our analysis is to see wether it's possible in certain cases there are such signals coming from deprotonation via the solvent can occur.  

As far as shapes are concerned, these appear very different (much thinner) from the rest of the samples which is concerning.
"""

# pentacene peak
m_start = 277 # low-mass cut off
m_stop = 282 # high-mass cut off
resolving_power = 1e4 # resolving power to use for shape parameter initialization
spec_pent = emg.spectrum('emg_spec_2.3_calibrated.txt',m_start=m_start,m_stop=m_stop,resolving_power=resolving_power)

"""Pentacene has iosotope distrubtion

mass | P
---|---
278.10955 | 100
279.11291 | 23.8
279.11583 | 0.2
280.11626 | 2.7
280.11919 | 0.1
281.11962 | 0.2

"""

spec_pent.detect_peaks(thres=2e-2,window='bartlett',window_len=9,width=1e-4)#2.25e-3,window_len=99,thres=10,plot_smoothed_spec=True,plot_2nd_deriv=True,plot_detection_result=True) 190	250.34	514.6	614.7	720.7	840.8	1008

"""0, 1, 2, and 4 seem to come from the 4 most probable peaks.  2 could then come from concurrent right and left skewness of 1 and 2 respectively in this picture."""

# Phthalocyanine peak
m_start = 513 # low-mass cut off
m_stop = 518 # high-mass cut off
resolving_power = 1e4 # resolving power to use for shape parameter initialization
spec_pthal = emg.spectrum('emg_spec_2.3_calibrated.txt',m_start=m_start,m_stop=m_stop,resolving_power=resolving_power)

"""Phthalocyanine has iosotope distrubtion

mass | P
---|---
514.16544 | 100
515.16248 | 2.9
515.1688 | 34.6
515.17172 | 0.3
516.16584 | 1
516.17215 | 5.8
516.17508 | 0.1
517.16919 | 0.2
517.17551 | 0.6
"""

spec_pthal.detect_peaks(thres=8e-3,window='bartlett',window_len=9,width=1e-4)#2.25e-3,window_len=99,thres=10,plot_smoothed_spec=True,plot_2nd_deriv=True,plot_detection_result=True) 190	250.34	514.6	614.7	720.7	840.8	1008

"""These resonably appear to be the three most probable peaks from the corresponding isotope distribution."""

# tpp peak
m_start = 613 # low-mass cut off
m_stop = 618 # high-mass cut off
resolving_power = 1e4 # resolving power to use for shape parameter initialization
spec_tpp = emg.spectrum('emg_spec_2.3_calibrated.txt',m_start=m_start,m_stop=m_stop,resolving_power=resolving_power)

"""TPP has iosotope distrubtion

mass | P
---|---
614.24705 | 100
615.24408 | 1
615.25041 | 48
616.24744 | 1
616.25376 | 11
617.25712 | 2
"""

spec_tpp.detect_peaks(thres=8e-3,window='bartlett',window_len=9,width=1e-4)#2.25e-3,window_len=99,thres=10,plot_smoothed_spec=True,plot_2nd_deriv=True,plot_detection_result=True) 190	250.34	514.6	614.7	720.7	840.8	1008

"""1 through 4 would be the isotope distrubution and then 0 would correspond to the deprotonation.  This distribution in particular was focused on when selecting the ToF parameters, so it's description is expected.

For sake of tutorial, the shape calibration can be done on the principle peak of the Phth. spectrum, and we can see what masses arise from it.
"""

isometric_tpp_masses = [614.24705-1.0079,614.24705,615.25041,616.25376,617.25712]
tpp_peak_indices = [0,1,2,3,4]
# #931493.6148385 #kev per amu
for index,mass in zip(tpp_peak_indices,isometric_tpp_masses):
  spec_tpp.set_lit_values(index,mass,1e-5)
spec_tpp.determine_peak_shape(index_shape_calib=1,x_fit_range=1.5)
spec_tpp.fit_peaks(index_mass_calib=1,x_fit_range=1.5)

"""One can see from the plots that the main peak shape is replicated over the four peaks for fitting.  These result in the masses in the column m_ion in the table.  The mass errors are in keV in the mass_error_keV column."""

